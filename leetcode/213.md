# 213.打家劫舍II
```
你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。
这个地方所有的房屋都围成一圈，这意味着第一个房屋和最后一个房屋是紧挨着的。
同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警 。
给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下今晚能够偷窃到的最高金额。


示例 1：
输入：nums = [2,3,2]
输出：3
解释：你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。

示例 2：
输入：nums = [1,2,3,1]
输出：4
解释：你可以先偷窃 1 号房屋（金额 = 1），然后偷窃 3 号房屋（金额 = 3）。
     偷窃到的最高金额 = 1 + 3 = 4 。

示例 3：
输入：nums = [1,2,3]
输出：3
```

分析
```
由于房屋是环形的，所以分两种情况考虑：
(1)偷第一个房屋到倒数第二个房屋之间的房屋
(2)偷第二个房屋到最后一个房屋之间的房屋
然后取这两种情况中的最大值
其余思想与198.打家劫舍类似
```

```java
class Solution {
    /**
     * 计算在给定的起始和结束索引范围内能够偷窃到的最高金额。
     *
     * @param nums 房屋存放金额的数组
     * @param start 开始偷窃的房屋的索引（包含）
     * @param end 结束偷窃的房屋的索引（包含）
     * @return 在给定范围内能够偷窃到的最高金额
     */
    public int robRange(int[] nums, int start, int end) {
        // first表示只偷第一个房屋时的金额
        int first = nums[start];
        // second表示偷第一个或第二个房屋时的最大金额
        int second = Math.max(nums[start], nums[start + 1]);
        for (int i = start + 2; i <= end; i++) { // 从第三个房屋开始遍历到结束房屋
            int temp = second; // temp用于临时保存second的值
            second = Math.max(first + nums[i], second);
            first = temp; // 更新first为前一个second的值，用于下一次迭代计算
        }
        return second; // 返回在给定范围内能够偷窃到的最高金额
    }

    /**
     * 计算在不触动警报装置的情况下，今晚能够偷窃到的最高金额。
     *
     * @param nums 房屋存放金额的数组
     * @return 能够偷窃到的最高金额
     */
    public int rob(int[] nums) {
        int n = nums.length;
        if (n == 0) return 0;
        // 如果只有一个房屋，直接返回该房屋的金额
        if (n == 1) return nums[0];
        // 如果有两个房屋，返回金额较大的那个房屋的金额
        if (n == 2) return Math.max(nums[0], nums[1]);
        // 由于房屋是环形的，所以分两种情况考虑：
        // 1. 偷第一个房屋到倒数第二个房屋之间的房屋
        // 2. 偷第二个房屋到最后一个房屋之间的房屋
        // 然后取这两种情况中的最大值
        int m1 = robRange(nums, 0, n - 2); // 第一种情况
        int m2 = robRange(nums, 1, n - 1); // 第二种情况
        return Math.max(m1, m2); // 返回两种情况中的最大值
    }
}
```
